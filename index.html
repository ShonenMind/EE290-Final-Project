<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Insert project title here">
    <title>INSERT PROJECT TITLE, EE290 Final Project</title>

    <!-- Fonts and Icons -->
    <link href="https://fonts.googleapis.com/css?family=Google+Sans|IBM+Plex+Sans|Noto+Sans|Castoro" rel="stylesheet">
    <link rel="stylesheet" href="./static/css/bulma.min.css">
    <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
    <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
    <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
    <link rel="stylesheet" href="./static/css/index.css">
    <link rel="icon" href="./static/images/favicon.png">

    <!-- MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]],
            },
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <!-- JavaScript -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script defer src="./static/js/fontawesome.all.min.js"></script>
    <script src="./static/js/bulma-carousel.min.js"></script>
    <script src="./static/js/bulma-slider.min.js"></script>
    <script defer src="./static/js/index.js"></script>
</head>
<body>
    <h1>Table of Contents</h1>
    <ul class="toc">
        <li><a href="#overview">Overview of Project</a></li>
        <li><a href="#data-generation">Data Generation</a></li>
    </ul>

    <h2 id="overview">Overview of Project</h2>

    <h4>Project Inspiration: <a href="https://ieeexplore.ieee.org/document/9024543" target="_blank">https://ieeexplore.ieee.org/document/9024543</a></h4>
    <p>
        Millimeter-wave (mmWave) small cell networks play an important role in 5G wireless communication systems. 
        By densely deploying a large number of mmWave small cell base stations (SBSs), thousands of connections 
        and high transmission rates are supported to provide a variety of local services [1], [2]. 
        The SBS provides short-range communications to mobile terminals (MTs) to reduce the propagation loss of 
        signal transmission [3]. With the help of mmWave, multiple SBSs can utilize a large number of antennas 
        to form directional analog beams to MTs and provide concurrent transmissions simultaneously. However, 
        as the number of SBSs and MTs increases, it becomes increasingly difficult to use traditional signal 
        processing methods to improve performance.
    </p>

    <p>
        For our project, we attempt to utilize machine learning (ML) to show a novel ML-based method for concurrent transmission in mmWave small cell networks.
    </p>

    <p>In the original paper, the authors follow a 3-step process:</p>
    <ul>
        <li>
            <strong>1. Random Distribution Modeling:</strong> 
            The large random distribution of SBSs is modeled by a heterogeneous Poisson point process (HPPP), 
            where the average sum rate (ASR) of MT under concurrent transmission can be obtained.
        </li>
        <li>
            <strong>2. Machine Learning for Beam Selection:</strong> 
            Downlink SBS conditions are established as a large database for machine learning training. An iterative 
            support vector machine (SVM) classifier is proposed for analog beam selection of each SBS.
        </li>
        <li>
            <strong>3. Iterative SMO Algorithm:</strong> 
            An iterative sequential minimal optimization (SMO) training algorithm is proposed, enabling SBSs to perform 
            highly efficient and low-complexity analog beam selection during concurrent transmissions.
        </li>
    </ul>

    <p>
        This process runs faster than traditional 
        <a href="https://www.mathworks.com/help/lte/ug/channel-estimation.html" target="_blank">channel estimation algorithms</a>
        on average.
    </p>

    <h4 style="text-decoration: underline;">For our project, we want to compare a naive Neural Network (NN) implementation, the paper's SMO algorithm, and our own Reinforced Learning (RL) approach.</h4>

    <h2 id="data-generation">Data Generation</h2>

    <p>The first <i>(and typically most important)</i> step of any ML-based project is to collect lots of <a href="https://www.linkedin.com/pulse/what-good-quality-training-dataset-machine-learning-tagx" target="_blank">good</a> data.</p>

    <p> Problem is... we don't have access to this data, and most papers on beamforming do not share their data.
      As a result, we had to implement our own data generation script that follows the paper's implementaiton.

      This meant curating a large dataset that followed a HPPP.
    </p>

    <p> </p>
    <body>
      <div class="algorithm">
          <div class="algorithm-title">Algorithm 1: mmWave Channel Model</div>
          
          <div class="keyword">Constants:</div>
          <div class="algorithm-block">
              \(\lambda_S\): SBS density in \(\mathbb{R}^2 \) plane<br>
              $R$: Maximum communication radius<br>
              $N_{SBS}$: Number of SBS antennas<br>
              $N_{MT}$: Number of MT antennas<br>
              $L$: Number of propagation paths<br>
              $N_C$: Number of candidate vectors in codebook, \(N_C > 2\)<br>
              $P_S$: Transmit power of SBS<br>
              $D_{MT}$, $D_S$: Antenna spacing at MT and SBS, \( \lambda/2 \)<br>
              $\sigma = \frac{2\pi}{\lambda}$: Wave number
          </div>
  
          <div class="keyword">Procedure:</div>
          <div class="algorithm-block">
              1. Calculate number of SBS:<br>
              <div class="equation">$N_S = \lfloor \lambda_S \pi R^2 \rfloor$</div>
              
              2. Generate data streams $d_S,k \in \mathbb{C}$ for $k = 1, \dots ,N_S$<br>
              
              3. For each SBS $k$, select beam $c_S,k$ from codebook:<br>
              <div class="equation">s_SBS,k = c_S,k d_S,k, (c_S,k ∈ C^(N_SBS×1))</div>
              
              4. Generate channel matrices H_S,k:<br>
              <div class="equation">H_S,k = γ ∑(l=1 to L) α_S,k,l a_MT(φ_MT,k,l)[a_S,k(φ_S,k,l)]^H</div>
              where:
              <div class="algorithm-block">
                  γ = √(N_SBS N_MT / L)<br>
                  α_S,k,l ∼ CN(0,1)<br>
                  Array steering vectors:<br>
                  <div class="equation">a_MT(φ_MT,k,l) = [1, e^(jσD_MT sin(φ_MT,k,l)), ..., e^(jσD_MT(N_MT-1)sin(φ_MT,k,l))]^T/√N_MT</div>
                  <div class="equation">a_S(φ_S,k,l) = [1, e^(jσD_S sin(φ_S,k,l)), ..., e^(jσD_S(N_SBS-1)sin(φ_S,k,l))]^T/√N_SBS</div>
              </div>
              
              5. Generate receive phase vector:<br>
              <div class="equation">g_MT = [e^(jθ₁), ..., e^(jθ_N_MT)] ∈ C^(1×N_MT)</div>
              
              6. Calculate received signal:<br>
              <div class="equation">y_MT = g_MT ∑(k=1 to N_S) H_S,k c_S,k d_S,k + g_MT n</div>
              
              7. Define channel matrix G:<br>
              <div class="equation">G = g_MT[H_S,1c_S,1 ⋯ H_S,N_Sc_S,N_S]</div>
              
              8. Apply Zero-Forcing equalization:<br>
              <div class="equation">y_MT,ZF = [d_S,1, ⋯, d_S,N_S]^T + (G^H G)^(-1) G^H g_MT n</div>
          </div>
      </div>
    </body>
</html>
